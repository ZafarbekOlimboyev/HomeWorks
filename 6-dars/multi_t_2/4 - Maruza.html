
<!DOCTYPE html>
<html lang="en">
<head>
<script data-ad-client="ca-pub-5893793281359863" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Multimedia MB so&#0145;rovlari</title>
    <link rel="stylesheet" href="css/bootstrap.min.css">
    <link rel="stylesheet" href="css/style.css">
    <script src="js/jquery.min.1.9.1.js"></script>
    <script type="text/javascript">
        $(function(){
            $('a[href^="#"]').click(function(){
                var target = $(this).attr('href');
                $('html, body').animate({scrollTop: $(target).offset().top}, 2000);//800 - длительность скроллинга в мс
                return false;
            });
        });
    </script>

</head>
<div>
<!--header-->
<div class="container-fluid">
    <div class="row">
        <div class="col-md-12">
            <div class="header">
                <h1><a href="https://multimediya.uz/"><img src="https://static.tuit.uz/uploads/1/W73eM8T-hn5cLRoa_rQWKshn3eUutXvm.png" width="50"/> </a>Multimedia ma’lumotlar bazasi</h1>
            </div>
        </div>
    </div>
</div>
<!--end header-->
<!--section theme-->
<div class="container">
    <div class="row">
        <div class="col-md-12">
            <div class="row">
                <div class="col-md-3 col-sm-3-3">
                    <div class="theme">
                        <img src="img/db.png" alt="books">
                                                <div class="mavzu">
                            <h5 class="text-center p-1">1-ma'ruza</h5>
                            <p class="aaa"><a class="aaa" href="index.php?mavzu=1">Multimedia ma&#0145;lumotlar bazasi faniga kirish</a></p>
                        </div>
                                                <div class="mavzu">
                            <h5 class="text-center p-1">2-ma'ruza</h5>
                            <p class="aaa"><a class="aaa" href="index.php?mavzu=2">Multimedia ma&#0145;lumotlar modeli tushunchasi</a></p>
                        </div>
                                                <div class="mavzu">
                            <h5 class="text-center p-1">3-ma'ruza</h5>
                            <p class="aaa"><a class="aaa" href="index.php?mavzu=3">Multimedia MB loyihalashda relyatsion yondoshuv</a></p>
                        </div>
                                                <div class="mavzu">
                            <h5 class="text-center p-1">4-ma'ruza</h5>
                            <p class="aaa"><a class="aaa" href="index.php?mavzu=4">Multimedia MB so&#0145;rovlari</a></p>
                        </div>
                                                <div class="mavzu">
                            <h5 class="text-center p-1">5-ma'ruza</h5>
                            <p class="aaa"><a class="aaa" href="index.php?mavzu=5">Multimediali ma&#0145;lumotlarni izlash</a></p>
                        </div>
                                                <div class="mavzu">
                            <h5 class="text-center p-1">6-ma'ruza</h5>
                            <p class="aaa"><a class="aaa" href="index.php?mavzu=6">Multimediali ma&#0145;lumotlar bazasini tashkil qilish</a></p>
                        </div>
                                                <div class="mavzu">
                            <h5 class="text-center p-1">7-ma'ruza</h5>
                            <p class="aaa"><a class="aaa" href="index.php?mavzu=7">Suratlarni ma&#0145;lumotlar bazasida saqlash</a></p>
                        </div>
                                                <div class="mavzu">
                            <h5 class="text-center p-1">8-ma'ruza</h5>
                            <p class="aaa"><a class="aaa" href="index.php?mavzu=8">Videoni ma&#0145;lumotlar bazasida saqlash</a></p>
                        </div>
                                                <div class="mavzu">
                            <h5 class="text-center p-1">9-ma'ruza</h5>
                            <p class="aaa"><a class="aaa" href="index.php?mavzu=9">Audioni ma&#0145;lumotlar bazasida saqlash</a></p>
                        </div>
                                                <div class="mavzu">
                            <h5 class="text-center p-1">10-ma'ruza</h5>
                            <p class="aaa"><a class="aaa" href="index.php?mavzu=10">XML va XML-ma&#0145;lumotlar bazasi</a></p>
                        </div>
                                                <div class="mavzu">
                            <h5 class="text-center p-1">11-ma'ruza</h5>
                            <p class="aaa"><a class="aaa" href="index.php?mavzu=11">Katta hajmli ob&#8217;ektlarni tashkil qilish va boshqarish</a></p>
                        </div>
                                                <div class="mavzu">
                            <h5 class="text-center p-1">12-ma'ruza</h5>
                            <p class="aaa"><a class="aaa" href="index.php?mavzu=12">Ko&#0145;p o&#0145;lchamli ma&#0145;lumotlar strukturasi</a></p>
                        </div>
                                            </div>
                </div>
                <div class="col-md-9">
                    <div class="little-info">
                        <h4 class="text-center"><span class="font-weight-bold">4-ma'ruza: </span>Multimedia MB so&#0145;rovlari</h4>
                        <h4 class="mb-4 font-weight-bold" style="text-align: center;">Reja:</h4>
                        <ol>
                                                        <li>
                                <a href="#1" class="perexod">
                                    SQL tili haqida tushuncha                                </a>
                            </li>
                                                        <li>
                                <a href="#2" class="perexod">
                                    SQL tilida ma&#0145;lumotlar turlari                                </a>
                            </li>
                                                        <li>
                                <a href="#3" class="perexod">
                                    Jadvallar yaratish va ularga cheklovlar kiritish                                </a>
                            </li>
                                                        <li>
                                <a href="#4" class="perexod">
                                    Maydon qiymatlarini tekshirish (CHECK cheklovi)                                </a>
                            </li>
                                                        <li>
                                <a href="#5" class="perexod">
                                    Oddiy SELECT so&#0145;rovlar va mantiqiy operatorlar                                </a>
                            </li>
                                                        <li>
                                <a href="#6" class="perexod">
                                    SQL turlari va strukturasi                                </a>
                            </li>
                                                    </ol>
                        </p>
                    </div>
                    <div class="more-info">
                                                    <h4 class="mb-4 font-weight-bold text-center" id="1">
                                SQL tili haqida tushuncha                            </h4>
                            <p>
                                SQL (Structured Query Language) strukturalashgan so&#0145;rov tili ma&#8217;nosini bildirib, u relyatsion ma&#0145;lumotlar bazasi bilan ishlash imkonini yaratib beradigan tildir. <br>
Ma&#8217;lumki, relyatsion modelning tarixi (va bilvosita SQL tarixi ham) 1970 yil Ye,F.Koddni (bu paytda u IBM  korporatsiyasining San Xosedagi  tadqiqot markazida ishlagan) maqolasi chiqqan davrdan boshlanadi. 1974 yil shu laboratoriyada ishlovchi D. Chemberlen  "Structured English Query Language" yoki SEQUEL deb nomlangan tilni e&#8217;lon qiladi.  1976 yil bu tilning qayta ishlangan SEQUEL/2 versiyasi yaratildi va u rasmiy ravishda SQL deb atalgan. Xozirgi kunda SQL qisqartmasini ba&#8217;zilar  "sikvel" deb talffuz etadi. Biroq  rasmiy ravishda u "es-kyu-el" deb o&#0145;qilishi kerak.<br>
SQL tili relyatsion algebra paydo bo&#0145;lgandan keyin  paydo bo&#0145;ldi va uning birinchi prototipi IBM Research  kompaniyasi tomonidan 70 yillar oxirida yaratilgan. Bu til birinchi IBM System R  nomli MBBT tarkibiga kiritilgan. Keyinchalik bu til ko&#0145;pgina tijorat MBBT tarkibida qo&#0145;llanilgan va keng tarqalganligi sababli vaqt o&#0145;tishi bilan relyatsion MBBT larda ma&#0145;lumotlar ustida amallar bajaruvchi tillarning norasmiy standarti bo&#0145;lib qoldi. SQL tilining birinchi ramiy standarti 1989 yil qabul qilingan. Ko&#0145;pgina MBBT lar ushbu standartni qo&#0145;llab &#8211; quvvatlaydi. Biroq ma&#0145;lumotlar bazasi bilan bog&#0145;liq axborot texnologiyalarining rivojlanishi va ba&#8217;zi talablarning paydo bo&#0145;lishi birinchi SQL standartini qayta ishlash va kengaytirishni taqoza etdi.<br>
1992 yil oxirida SQL tilining yangi xalqaro standarti  (SQL/92 yoki SQL2) qabul qilindi unda ham ba&#8217;zi kamchiliklar aniqlangan, biroq shunga qaramasdan SQL/89 ga nisbatan aniq va to&#0145;liqroq xisoblanadi. Xozirgi paytda ko&#0145;pgina MBBT ishlab chiqaruvchilar o&#0145;z maxsulotlarini SQL2 standartini qanoatlantiradigan qilib o&#0145;zgartirdilar.<br>
1999 yil SQL3 deb atalgan yangi standart paydo bo&#0145;ldi. Agar SQL1 va SQL2 standartlari biri &#8211;biridan miqdor jixati bilan farq qilgan bo&#0145;lsa, SQL3 standarti sifat jixatlari bilan farqlanadi. SQL3 ga murakkab strukturaga ega ma&#0145;lumotlar tipini ishlatish imkonini beradigan yangi ma&#0145;lumotlar tipi kiritilgan. Bu tipni ob&#8217;ektga mo&#0145;ljallanganlik darajasi yuqori xisoblanadi. SQL tilini tula qonli an&#8217;anaviy dasturlash tillari tarkibiga kiritib bo&#0145;lmaydi. Chunki unda dastur bajarilishini boshqaruvchi va boshqa ko&#0145;pgina an&#8217;anaviy operattorlar yo&#0145;q. Unda faqat ma&#0145;lumotlar bazasida saqlanayotgan ma&#0145;lumotilarga murojaat qiluvchi operatorlar mavjud. <br>
SQL tili foydalanuvchi relyatsion ma&#0145;lumotlar bazasi bilan muloqat qilishi uchun mo&#0145;ljallangan bo&#0145;lib, quyidagi 3 ta qismdan iborat:<br>
&#8226; DDL (Data Definition Language) &#8211; ma&#0145;lumotlarni aniqlash tili. Ma&#0145;lumotlar bazasini  (jadvallarini, indekslarini va x.k.)  yaratish va uning sxemasini taxrirlash uchun mo&#0145;ljallangan..<br>
&#8226; DCL (Data Control Language) &#8211; ma&#0145;lumotlarni boshqarish tili. Foydalanuvchilarning ma&#0145;lumotlar bazasi ob&#8217;ektlariga murojatini chegaralash operatorlaridan iborat.<br>
&#8226; DML (Data Manipulation Language) &#8211; ma&#0145;lumotlarni qayta ishlash tili. Ma&#0145;lumotlar bazasi jadvallariga o&#0145;zgartirishlar kiritish uchun mo&#0145;ljallangan.<br>
Ma&#0145;lumotlar bazasi bilan ishlovchi ixtiyoriy til foydalanuvchiga quyidagi imkoniyatlarni yaratishi lozim:<br>
&#8226; strukturasini to&#0145;la tavsiflagan xolda ma&#0145;lumotlar bazasini va jadvallarini yaratish;<br>
&#8226; ma&#0145;lumotlar ustida manipulyatsiya amallarini bajarish, masalan, jadvallardan ma&#0145;lumotlarni kiritish, taxrirlash, va o&#0145;chirish;<br>
&#8226; oddiy va murakkab so&#0145;rovlarni bajarish.<br>
Bundan tashqari, ma&#0145;lumotlar bazasi bilan ishlovchi til yuqoridagi amallarni bajarish uchun foydalanuvchilardan kam urinishlarini talab qilishi, hamda komandalarining sintaksisi va tuzilishi o&#0145;zganish uchun ososn va tushunarli bo&#0145;lishi kerak. Nixoyat bu til universal bo&#0145;lishi kerak. Bu bir MBBT dan boshqasiga o&#0145;tganda komandalarni bir xil strukturasi va sintaksisidan foydalanishni ta&#8217;xminlaydi. SQL tili bu talablarni barchasini qanoatlantiradi.<br>
                            </p>
                                                    <h4 class="mb-4 font-weight-bold text-center" id="2">
                                SQL tilida ma&#0145;lumotlar turlari                            </h4>
                            <p>
                                SQL tilida ma&#0145;lumotlarning quyidagi asosiy turlari ishlatilib, ularning formatlari har xil MBBT lar uchun farq qilishi  mumkin:<br>                            </p>
                                                    <h4 class="mb-4 font-weight-bold text-center" id="3">
                                Jadvallar yaratish va ularga cheklovlar kiritish                            </h4>
                            <p>
                                Jadvallarni yaratish. Jadvallar CREATE TABLE buyrug&#0145;i bilan yaratiladi. Bu buyruq qatorlarsiz bo&#0145;sh jadval yaratadi. U jadval nomini, ma&#8217;lum tartibda ko&#0145;rsatilgan ustunlar nomlari ketma &#8211; ketligi, ma&#0145;lumotlar turlari va ustunlar o&#0145;lchovini aniqlaydi. <br>
CREATE TABLE    buyrug&#0145;ining umumiy yozilishi:<br>
    CREATE TABLE <jadval nomi><br>
         ( <ustun nomi> <ma&#0145;lumot turi>[(<ustun o&#0145;lchovi>)],<br>
           <ustun nomi> <ma&#0145;lumot turi>[(<ustun o&#0145;lchovi, ... );<br>
Jadval yaratishda va ular ustida ish yuritishda quyidagi 2 ta jadvaldan iborat ma&#0145;lumotlar bazasini misol sifatida qaraymiz. <br>
 Sotuvchilar (Salepeople):
<br>
 SNum &#8211; xar bir sotuvchi unikal nomeri,<br>
 SName &#8211; sotuvchi nomi,<br>
 City &#8211; sotuvchi adresi ( shaxri ),<br>
 Comm &#8211; sotuvchilarning o&#0145;nli shakldagi   komission foydasi.<br>
<br>
<br>
Buyurtmachilar (Customers):<br>
<br>
 CNum &#8211; xar bir buyurtmachi unikal nomeri;<br>
 CName &#8211; buyurtmachi nomi;<br>
 City &#8211; buyurtmachi adresi (shaxri );<br>
Rating &#8211; buyurtmachining boshqalardan ustunlik darajasini ko&#0145;rsatuvchi kod;<br>
 SNum &#8211; shu buyurtmachiga tayinlangan sotuvchi nomeri.<br>
Misol uchun sotuvchilar jadvalini yaratish:<br>
CREATE TABLE Salepeople<br>
      ( SNum integer,  SName  char(10),  City char(10), Comm decimal );<br>
<br>
Cheklovlarni kiritish. Jadvalni yaratayotganda (yoki uni o&#0145;zgartirayotganda), maydonlarga kiritilayotgan qiymatlarga cheklovlar o&#0145;rnatish mumkin. Bu holda SQL cheklovlarga to&#0145;g&#0145;ri kelmaydigan hamma qiymatlarni rad etadi. <br>
     Maydonga bo&#0145;sh (NULL) qiymatlar kiritilishi oldini olish uchun CREATE TABLE buyrug&#0145;ida NOT NULL cheklovi ishlatiladi. Masalan, birlamchi kalitlar xech qachon bo&#0145;sh bo&#0145;lmasliklari kerak, shuning uchun Salepeople jadvalini quyidagicha yaratish mumkin:<br>
CREATE TABLE Salepeople<br>
          ( Snum     integer NOT NULL,<br>
            Sname   char(10),  city char(10), comm decimal);<br>
 Ko&#0145;p hollarda ustunga kiritilgan qiymatlar bir biridan farq qilishi kerak bo&#0145;ladi. Agar ustunga UNIQUE cheklovi o&#0145;rnatilsa, unda ustunga qiymat kiritishga urinish rad etiladi. Bu cheklov bo&#0145;sh bo&#0145;lmaydigan (NOT NULL) deb e&#8217;lon qilingan maydonlarga qo&#0145;llaniladi. Masalan:<br>
  CREATE TABLE Salepeople<br>
          ( SNum     integer NOT NULL UNIQUE,<br>
            Sname   char(10),  city char(10), comm decimal);<br>
Jadval cheklovi UNIQUE maydonlar guruhiga ham o&#0145;rnatilishi mumkin. Bu bir necha maydonlar qiymatlari kombinatsiyasi unikalligini ta&#8217;minlaydi.<br>                            </p>
                                                    <h4 class="mb-4 font-weight-bold text-center" id="4">
                                Maydon qiymatlarini tekshirish (CHECK cheklovi)                            </h4>
                            <p>
                                CHECK cheklovi jadvalga kiritilayotgan ma&#0145;lumot qabul qilinishidan oldin mos kelishi lozim bo&#0145;lgan shart kiritishga imkon beradi. CHECK cheklovi CHECK kalit so&#0145;zi ko&#0145;rsatilgan maydondan foydalanuvchi shartli ifodadan iboratdir. Misol uchun Salepeople jadvali Comm ustuniga kiritilayotgan qiymat 1 dan kichik bo&#0145;lsin.<br>
CREATE TABLE Salepeople<br>
     ( SNum     integer NOT NULL PRIMARY KEY,<br>
       SName    char(10) NOT NULL UNIQUE,<br>
       City        char(10),<br>
       Comm    decimal CHECK ( Comm < 1 ));<br>
CHECK cheklovidan maydonga ma&#8217;lum qiymatlarini kiritishdan himoya qilib, xatolar oldini olish uchun foydalanish mumkin. Masalan, mahsulotni sotish shaxobchalariga ega bo&#0145;lgan shaharlar faqat London, Barselona, San Xose va  Nyu York bo&#0145;lsin.<br>
    CREATE TABLE Salepeople<br>
(SNum     integer NOT NULL PRIMARY KEY,<br>
 SName    char(10) NOT NULL UNIQUE,<br>
 City char(10) CHECK (City IN ('London','New York','San Jose', 'Barselona')),  Comm    decimal CHECK ( Comm < 1 ));<br>
CHECK jadval cheklovi sifatida kelishi mumkin. Bu shartga bir necha maydon kiritishga imkon beradi. Masalan:<br>
CREATE TABLE Salepeople<br>
     ( SNum     integer NOT NULL PRIMARY KEY,<br>
       SName    char(10) NOT NULL UNIQUE,<br>
       City        char(10),<br>
       Comm    decimal,<br>
       CHECK  (Somm < .15 OR City = 'Barcelona'));<br>
<br>
Ko&#0145;zda tutilgan qiymatlarni o&#0145;rnatish<br>
<br>
Biror bir maydon uchun qiymat ko&#0145;rsatmagan holda jadvalga satr qo&#0145;shilish kerak bo&#0145;lsa, SQL bunday maydonga kiritish uchun ko&#0145;zda tutilgan qiymatga ega bo&#0145;lishi kerak, aks holda buyruq rad etiladi. Eng umumiy ko&#0145;zda tutilgan qiymat NULL qiymatdir. CREATE TABLE buyrug&#0145;ida ko&#0145;zda tutilgan qiymat DEFAULT operatori orqali, ustun cheklovi sifatida ko&#0145;rsatiladi. Masalan:<br>
CREATE TABLE Salepeople<br>
     ( SNum     integer NOT NULL PRIMARY KEY,<br>
       SName    char(10) NOT NULL UNIQUE,<br>
       City        char(10) DEFAULT 'New York',<br>
       Comm    decimal CHECK ( Comm < 1 ));<br>
<br>
Maydonlar qiymatlarini kiritish, o&#0145;chirish va o&#0145;zgartirish<br>
<br>
Jadvallarni o&#0145;chirish. Faqat bo&#0145;sh jadvalni o&#0145;chirish mumkin. Jadvalni o&#0145;chirish buyrug&#0145;i quyidagi ko&#0145;rinishga ega:<br>
  DROP TABLE <jadval nomi>;  Masalan: DROP TABLE Salepeople;<br>
Jadvalni yaratilgandan so&#0145;ng o&#0145;zgartirish. Jadvalni o&#0145;zgartirish uchun ALTER TABLE buyrug&#0145;idan foydalaniladi. Bu buyruqda jadvalga yangi ustunlar qo&#0145;shish, ustunlarni o&#0145;chirish, ustunlar kattaligini o&#0145;zgartirish, hamda cheklovlarni qo&#0145;shish va olib tashlash imkoniyatlariga ega. <br>
Jadvalga ustun qo&#0145;shish buyrug&#0145;i:<br>
 ALTER TABLE <jadval nomi> ADD <ustun nomi> <br>
                             <ma&#0145;lumot turi> <o&#0145;lchami>;<br>
  Masalan:<br>
  ALTER TABLE Salepeople ADD Phone CHAR(7);<br>
Qiymatlarni kiritish. Hamma satrlar SQLda INSERT buyrug&#0145;i yordamida kiritiladi. INSERT quyidagi formatga ega:<br>
  INSERT  INTO   <table name | view name> [(column [,column] ...)]<br>
                  VALUES ( <value> [,<value>] ... );<br>
Masalan, sotuvchilar jadvaliga yangi satr kiritish uchun quyidagi buyruqdan foydalanish mumkin:<br>
INSERT INTO Salepeople VALUES (11, 'Peel', 'London', .12);<br>
 Ustun nomlarini ko&#0145;rsatish ham mumkin, masalan:<br>
INSERT INTO Salepeople (Sname, Comm, SNum)<br>
               VALUES ('Peel', .12, 11);<br>
Bu yerda e&#8217;tibor berilsa City ustuni tashlab yuborilgan, chunki unga ko&#0145;zda tutilgan qiymat kiritiladi.<br>
Satrlarni o&#0145;chirish. Satrlarni jadvaldan DELETE buyrug&#0145;i bilan o&#0145;chirish mumkin. U alohida qiymatlarni emas faqat satrlarni o&#0145;chiradi. DELETE quyidagi formatga ega:<br>
    DELETE  FROM  <table name | view name> [WHERE search-condition];<br>
 Masalan, sotuvchilar jadvalidagi hamma satrlarni o&#0145;chirish uchun, quyidagi shartni kiritish mumkin:   DELETE FROM Salepeople;<br>
 Ma&#8217;lum satrlarni o&#0145;chirish uchun shartlardan foydalaniladi. Masalan, jadvaldan Axelrod sotuvchini o&#0145;chirish uchun uning nomerini shartda berish kerak:<br>
  DELETE FROM Salepeople  WHERE SNum = 13;<br>
Maydon qiymatlarini o&#0145;zgartirish. O&#0145;zgartirish UPDATE buyrug&#0145;i yordamida bajariladi. Bu buyruqda UPDATE ifodasidan so&#0145;ng jadval nomi va SET ifodasidan so&#0145;ng ma&#8217;lum ustun uchun o&#0145;zgartirish ko&#0145;rsatiladi. UPDATE ikki formatga ega. Ulardan birinchisi:<br>
  UPDATE  <table name | view name><br>
                   SET column = expression [, column = expression] ...<br>
                   [WHERE search-condition]<br>
bu yerda expression - bu ustun | ifoda | konstanta | o&#0145;zgaruvchi.<br>
    Ikkinchi variant:<br>
UPDATE  <table name><br>
                 SET  column = expression, ...<br>
                 [ FROM  table-list ]<br>
                 [ WHERE search-condition ]<br>
Masalan, hamma buyurtmachilar bahosini 200 ga o&#0145;zgartirish mumkin:<br>
  UPDATE Customers  SET Rating = 200;<br>
Ma&#8217;lum satrlarni o&#0145;zgartirish uchun DELETE dagi kabi shartlardan foydalanish kerak. Masalan, Peel (SNum=11) sotuvchining hamma buyurtmachilari uchun bir xil o&#0145;zgartirish quyidagicha kiritiladi:<br>
  UPDATE Customers   SET Rating = 200   WHERE SNum = 11;<br>
SET vergul bilan ajratilgan ixtiyoriy sondagi ustunlarga qiymat tayinlashi mumkin. Masalan:<br>
  UPDATE Salepeople SET SName ='Gibson', City='Boston', Comm=.10<br>
                   WHERE SNum = 14;<br>
UPDATE buyrug&#0145;ining SET jumlasida ifodalarni ham ishlatish mumkin. Masalan:  UPDATE Salepeople SET Comm = Comm * 2;<br>
<br>
                            </p>
                                                    <h4 class="mb-4 font-weight-bold text-center" id="5">
                                Oddiy SELECT so&#0145;rovlar va mantiqiy operatorlar                            </h4>
                            <p>
                                SELECT operatori MB jadvallaridan natijaviy to&#0145;plam olish uchun mo&#0145;ljallangandir. SELECT operatori yordamida MBga so&#0145;rov beriladi va u foydalanuvchiga ma&#0145;lumotlarning natijaviy to&#0145;plamini qaytaradi. Bu ma&#0145;lumotlar jadval shaklida qaytariladi. Bu jadval keyingi SELECT operatori tomonidan yana qayta ishlanishi ham mumkin.<br>
SELECT operatori SQL quyidagi ko&#0145;rinishga ega: <br>
SELECT  [ALL]  <uctunlar><br>
FROM   jadval <br>
WHERE  izlash sharti<br>
GROUP BY  ustunlar<br>
HAVING  izlash sharti<br>
ORDER BY  tartiblash spesifikatori<br>
Masalan, OFFICES jadvalidagi hamma yozuvlarni qaytaruvchi sodda so&#0145;rov quyidagicha yoziladi.   SELECT * FROM OFFICES<br>
Misol: Hamma xizmatchilarning nomlari, ofislari va ishga olish sanalari ro&#0145;yxatini hosil qilish. <br>
SELECT NAME, REP_OFFICE, HIRE_DATE FROM SALESREPS<br>
SELECT operatori  WHERE sharti berilgan shart asosida kerakli ma&#0145;lumotlarni qaytarish uchun xizmat qiladi. Masalan, sotuvlarda haqiqiy hajmi rejadan oshgan ofislarni ko&#0145;rsatish kerak. <br>
 SELECT CITY, SALES, TARGET FROM OFFICES<br>
   WHERE SALES > TARGET<br>
Nomeri 105 ga teng bo&#0145;lgan xizmatchi nomi, haqiqiy va rejadagi sotuvlar hajmini ko&#0145;rsatish: <br>
SELECT SALES, NAME, QUOTA FROM SALESREPS<br>
  WHERE EMPL_NUM = 105<br>
Agar izlash sharti TRUE bo&#0145;lsa qator natijaviy to&#0145;plamga qo&#0145;shiladi, agar izlash sharti FALSE bo&#0145;lsa, qator natijaviy to&#0145;plamga qo&#0145;shilmaydi, agar NULL bo&#0145;lsa ham natijaviy to&#0145;plamdan chiqariladi. O&#0145;z ma&#8217;nosiga ko&#0145;ra WHARE, kerakli yozuvlarni qoldiruvchi filtr sifatida ishlatiladi.<br>
 		<br>
Mantiqiy operatorlar<br>
<br>
BETWEEN va IN operatorlari. BETWEEN operatori - bu qiymatlar diapazoniga tegishlilikni tekshirishdir. Misol: Narxi har xil diapazonga mos keluvchi buyurtmalarni topish. <br>
SELECT ORDER_NUM, AMOUNT  FROM ORDERS<br>
 WHERE  AMOUNT BETWEEN 20.000  AND 29.999<br>
NOT ifodasi shartni teskarisiga o&#0145;giradi, yani tegishli emas ma&#8217;nosini bildiradi. NOT ifodasi yordamida berilgan diapazonga tegishlilikni tekshirish mumkin, masalan: sotuvlar haqiqiy hajmlari rejaning 80 dan 120 protsentgacha bo&#0145;lgan oraliqqa tushmaydigan xizmatchilar ro&#0145;yxatini chiqarish. <br>
SELECT NAME, SALES, QUOTA  FROM SALESREPS<br>
 WHERE SALES NOT BETWEEN (0.8 * QUOTA)  AND (1.2 * QUOTA)<br>
 IN operatori to&#0145;plamga tegishlilikni tekshiradi. Masalan, to&#0145;rtta aniq xizmatchilar tomonidan olingan hamma buyurtmalarni aniqlash. <br>
 SELECT ORDER_NUM, REP, AMOUNT  FROM ORDERS<br>
  WHERE REP IN (107, 109, 101, 103)<br>
NOT IN yordamida diapazonga "tegishli emaslikni " tekshirish mumkin.<br>
LIKE operatori. Quyidagicha '%' shablonli LIKE operatorini qaraymiz: <br>
 SELECT COMPANY, CREDIT_LIMIT  FROM CUSTOMERS<br>
 WHERE COMPANY LIKE '%n'<br>
Bu xolda LIKE '%n' operatori 'n' harfiga tugaydigan hamma yozuvlarni ko&#0145;rsatadi, agar % shabloni birinchi kelsa: <br>
 SELECT COMPANY, CREDIT_LIMIT  FROM CUSTOMERS<br>
 WHERE COMPANY LIKE '%gan'<br>
Agar faqat bitta simvol ixtiyoriy bo&#0145;lsa '_'  shabloni qo&#0145;llaniladi. Masalan:<br>
SELECT COMPANY, CREDIT_LIMIT FROM CUSTOMERS<br>
WHERE COMPANY LIKE 'Ap_lsin'<br>
Yozuvlarni tartiblash, ORDER BY ifodasi. SELECT operatori tarkibida natijaviy yozuvlarni tartiblangan holda taqdim etish uchun ORDER BY ifodai ko&#0145;zda tutilgan. Masalan, agar o&#0145;quvchilar ro&#0145;yxatini alfavit tartibida yoki tovarlar narxini kamayish tartibida chiqarish zarur bo&#0145;lsa, u holda bu ifodadan foydalanish kerak bo&#0145;ladi.<br>
Quyidagi misolni ko&#0145;ramiz: Har bir offis uchun sotuvlar haqiqiy hajmlarini regionlar nomlari, har bir regionda esa shaharlar nomlari bo&#0145;yicha alfavit tartibida chiqarish. <br>
SELECT CITY, REGION, SALES  FROM OFFICES<br>
 ORDER BY REGION, CITY<br>
Masalan: Sotuvlari haqiqiy xajmlari kamayish tartibida bo&#0145;lgan offislar ro&#0145;yxatini chiqarish. <br>
SELECT CITY, REGION, SALES  FROM OFFICES<br>
 ORDER BY SALES DESC<br>
Sotuvlar hajmlarini DESC predikatini qo&#0145;llab kamayish tartibida chiqaramiz. O&#0145;sish tartibida chiqarish uchun ASC predikati qo&#0145;&#0145;llanadi.Bu predikat ko&#0145;zda tutilgan bo&#0145;lib, uni ko&#0145;rsatish shart emas. <br>
<br>
Bir necha jadvallar bilan ishlash<br>
<br>
Jadvallarni jamlashtirish. Jamlashtirish relyatsion ma&#0145;lumotlar bazasi operatsiyalaridan biri bo&#0145;lib, jadvallar orasidagi aloqani belgilaydi va ulardan ma&#0145;lumotni bitta buyruq yordamida ajratishga imkon beradi. Jamlashda jadvallar FROM buyrug&#0145;idan so&#0145;ng ro&#0145;yxat sifatida tasvirlanadi. So&#0145;rov predikati ixtiyoriy jadval ixtiyoriy ustuniga tegishli bo&#0145;lishi mumkin. Jamlashning eng soddasi bu dekart ko&#0145;paytmasidir, uni quyidagicha bajarish mumkin:<br>
  SELECT Customers.*, Salepeople.*  FROM Salepeople, Customers;  <br>
Lekin bu yerda hosil bo&#0145;lgan jadval keraksiz ma&#0145;lumotlarga ega. Keraksiz satrlarni olib tashlash uchun WHERE jumlasidan foydalaniladi.<br>
Masalan: berilgan shahardagi sotuvchilar va buyurtmachilar ixtiyoriy kombinatsiyasini ko&#0145;rish uchun quyidagini kiritish lozim:<br>
  SELECT Customers.CName, Salepeople.SName, Salepeople.City<br>
        FROM Salepeople, Customers<br>
             WHERE Salepeople.City = Customers.City;<br>
Jamlashda SQL bir necha jadval satrlari kombinatsiyasini predikatlar bo&#0145;yicha solishtirishdir. Misol: har bir sotuvchiga mos keluvchi buyurtmachilar ro&#0145;yxatini chiqarish:<br>
  SELECT Customers.CName, Salepeople.SName<br>
       FROM Customers, Salepeople<br>
              WHERE Salepeople.SNum = Customers.SNum;<br>
Sodda joylashtirilgan ostki so&#0145;rovlar. <br>
SQL yordamida so&#0145;rovlarni bir birining ichiga joylashtirish ham mumkin. Odatda ichki so&#0145;rov qiymat hosil qiladi va bu qiymat tashqi predikat tomonidan tekshirilib, to&#0145;g&#0145;ri yoki noto&#0145;g&#0145;riligi tekshiriladi. <br>
  Misol: bizga sotuvchi nomi ma&#8217;lum: Motika, lekin biz SNUM maydoni qiymatini bilmaymiz va buyurtmachilar jadvalidan hamma buyurtmalarni ajratib olmoqchimiz.  Buni quyidagicha amalga oshirish mumkin:<br>
  SELECT * FROM Orders WHERE SNum =<br>
                ( SELECT SNum FROM Salepeople<br>
                  WHERE SName = 'Motika&#8217; );<br>
Agar ostki so&#0145;rovda IN operatoridan foydalanilsa, ixtiyoriy sondagi satrlar hosil qilish mumkin.  Misol: Londondagi sotuvchilar uchun hamma buyurtmalarni ko&#0145;rsatish.<br>
  SELECT * FROM Orders  WHERE SNum IN<br>
         ( SELECT SNum FROM Salepeople WHERE City = 'London' );<br>
Bu natijani jamlanma orqali ham hosil qilish mumkin. Lekin odatda ostki so&#0145;rovli so&#0145;rovlar tezroq bajariladi. Ostki so&#0145;rovlarni HAVING izlash sharti ichida ishlatish ham mumkin. Bu ostki so&#0145;rovlar agar ko&#0145;p qiymatlar qaytarmasa agregat funksiyalaridan yoki GROUP BY yoki HAVING operatorlaridan foydalanishi mumkin. Misol:<br>
SELECT Rating, COUNT (DISTINCT CNum) FROM Customers<br>
      GROUP BY Rating<br>
      HAVING Rating >( SELECT AVG (Rating) FROM Customers<br>
                       WHERE City = 'San Jose' );<br>
Bu buyruq San Jose dagi baholari o&#0145;rtachadan yuqori bo&#0145;lgan buyurtmachilarni aniqlaydi.<br>
<br>
UNION ifodasidan foydalanish.  UNION ifodasi bir yoki bir necha so&#0145;rovlar natijasini birlashtirishga imkon beradi.  <br>
  Misol: Londonda joylashgan hamma sotuvchilar va buyurtmachilarni bitta jadvalda chiqarish.<br>
  SELECT SNum, SName FROM Salepeople WHERE City = 'London'<br>
  UNION<br>
  SELECT CNum, CName FROM Customers WHERE City = 'London';<br>
<br>
So&#0145;rovlarda funksiyalar<br>
<br>
Agregat funksiyalar qo&#0145;llanishi.<br>
Agregat (yoki STATIK) funksiyalar sonli yoki hisoblanuvchi ustunlar bilan ishlaydi. Agregat funksiya argumenti butun ustun bo&#0145;lib, bitta qiymat qaytaradi. Bu funksiyalarga quyidagilar kiradi: <br>
&#8226;	SUM() &#8211; ustundagi hamma qiymatlar summasini hisoblash. <br>
&#8226;	AVG() &#8211; ustundagi hamma qiymatlar o&#0145;rtachasi qiymatini hisoblash. <br>
&#8226;	MIN()  &#8211; ustundagi hamma qiymatlar eng kichigini aniqlash. <br>
&#8226;	MAX() &#8211; ustundagi hamma qiymatlar eng kattasini aniqlash. <br>
&#8226;	COUNT() &#8211; ustundagi qiymati sonini aniqlash. <br>
&#8226;	COUNT(*) &#8211; so&#0145;rov natijasi jadvalidagi satrlar sonini aniqlash. <br>
Agregatlash argumenti bo&#0145;lib ustun nomidan tashqari ixtiyoriy matematik ifoda xizmat qilishi ham mumkin. Misol: Sotuv kompaniyada reja bajarilishining o&#0145;rtacha protsentini aniqlash. <br>
SELECT AVG(100 * (SALES/QUOTA))	FROM SALESREPS<br>
Masalan, sotuv kompaniyasida sotuvlar xajmini chiqarish. <br>
SELECT SUM(QUOTA), SUM(SALES)	FROM SALESREPS<br>
AVG() agregatlash funksiyasiga yana bir sodda misolni ko&#0145;ramiz. Masalan:  "ACI" ishlab chiqaruvchi mollari o&#0145;rtacha narxini hisoblash. <br>
SELECT AVG(PRICE)	FROM PRODUCTS<br>
	WHERE MFR_ID = 'ACI'<br>
Ekstremumlarni topishda MIN() va MAX() funksiyalari sonli ustunlar, sanalar va satrli o&#0145;zgaruvchilar bilan ishlaydi. Eng sodda qo&#0145;llanish sonlar bilan ishlash. Masalan, eng ko&#0145;p va kam sotuvlar rejadagi hajmini chiqarish. <br>
SELECT MIN (QUOTA), MAX (QUOTA) FROM SALESREPS<br>
Masalan, buyurtmalardan eng oldin berilgan so&#0145;rov sanasini topish. <br>
SELECT MIN(ORDER_DATE)	FROM ORDERS<br>
MBdagi yozuvlar sonini sanash uchun COUNT() qo&#0145;llaniladi. Bu funksiya son qiymat qaytaradi. Masalan: kompaniya mijozlari sonini chiqarish. <br>
SELECT COUNT(CUST_NUM) FROM CUSTOMERS<br>
COUNT(*) funksiyasi satrlar sonini hisoblaydi. Misol <br>
SELECT COUNT(*) FROM ORDERS<br>
Agregat funksiyalar jadval uchun natijaviy satr hosil ham qiladi.  Masalan: Buyurtma o&#0145;rtacha narxini chiqarish. <br>
SELECT AVG(AMOUNT) FROM ORDERS<br>
                            </p>
                                                    <h4 class="mb-4 font-weight-bold text-center" id="6">
                                SQL turlari va strukturasi                            </h4>
                            <p>
                                Yuqorida ta&#8217;kidlab o&#0145;tilganidek SQL  tili tarkibida xisoblash jarayonini boshqarish imkonini beruvchi IF ... THEN ...ELSE, GO TO, DO ... WHILE  kabi buyruqlar mavjud emas. Bunday masalalar dasturiy yo&#0145;l bilan (dasturlash tili yoki masalalarni boshqarish tili) yoki interaktiv xolda (foydalanuvchining so&#0145;rovlari asosida) amalga oshiriladi. Imkoniyati cheklanganligi sababli (xisoblash jarayonini boshqarish imkoniyati) SQL  tili 2 ta usulda qo&#0145;llanilish mumkin. Birinchi  usulda interaktiv ishlash nazarda tutiladi. Bunda foydalanuvchi SQL  operatorlarini terminaldan beradi. Ikkinchi usulda protsedurali tildagi dasturga SQL tili operatorlari kiritiladi. <br>
Interaktiv rejimda ma&#0145;lumotlar bazasi bilan ishlashda foydalanuvchi muloqat rejimida ishlaydi, ya&#8217;ni SQL tilidagi so&#0145;rovni kiritadi va natijani oladi, yani so&#0145;rovni kiritadi va natijag ega bo&#0145;ladi va x.k.<br>
Kiritilgan SQL rejimida boshqa dasturlash tillarida yaratigan dastur tarkibiga kiritiladi. Bu ma&#0145;lumotlar bazasi bilan boshqa algoritmik tillarda yaratilgan amaliy dasturlar orqali ishlashni ta&#8217;minlaydi. Biroq bu yerda qo&#0145;shimcha dasturiy vosita kerak bo&#0145;ladi. U dasturlash tili bilan SQL operatorlari o&#0145;rtasidagi interfeysni ta&#8217;minlab beradi.<br>
<br>
Atamalar<br>
<br>
SQL til yordamida ma&#0145;lumotlar bazasiga beriladigan so&#0145;rov deganda joriy buyruq tavsiflagan va ma&#0145;lumotlar bazasini boshqarish tizimi tomonidan bajarish uchun mo&#0145;ljallangan ma&#0145;lumotlar bazasi ustida bajariladigan buyruq tushuniladi.<br>
So&#0145;rov  SQL tili opreatorlari yordamida yaratiladi. Operatorlar so&#0145;zlar deb ataluvchi aloxida ma&#8217;noli qismlardan tashkil topadi. Operatorlar  sintaksisi SQL tilining standartida belgilab berilgan. <br>
SQL tili relyatsion ma&#0145;lumotlar bazasi bilan ishlashiga qaramasdan &#34;munosabat&#34; atamasi o&#0145;rniga &#34;jadval&#34; atamasi, &#34;kortej&#34; va &#34;atribut&#34; atamalari o&#0145;rniga &#34;satr&#34; va &#34;ustun&#34; atamalari ishlatiladi.<br>
<br>
SQL strukturasi va operatorlari<br>
<br>
SQL tili 1 jadvalda tasvirlangan bo&#0145;limlardan iborat.<br>
1 jadval. Ma&#0145;lumotlarni aniqlash operatorlari DDL(Data Definition Language � ma&#0145;lumotlarni aniqlash tili)<br>
2 jadval. Ma&#0145;lumotlarni manipulyatsiyalash operatorlari Data Manipulation Language (DMP)<br>
3 jadval.  Data Query Language (DQL) so&#0145;rov tili<br>
4  jadval. Tranzaksiyalarni boshqarish operatorlari<br>
5. Jadval.  Ma&#0145;lumotlarni boshqarish operatorlari &#8226; DCL (Data Control Language) &#8211; ma&#0145;lumotlarni boshqarish<br>
Ko&#0145;pincha ustunlardagi qiymatlarning maksimal, minimal va o&#0145;rtacha qiymatlarini xisoblashga to&#0145;g&#0145;ri keladi. Masalan, o&#0145;rtacha ballni xioblash zarurati paydo bo&#0145;ladi. Bunday xisoblashlarni bajarish uchun  SQL tilida maxsus agregat funksiyalari mavjud:<br>
MIN &#8211; ustundagi minimal qiymat;<br>
MAX &#8211; ustundagi maksimal qiymat;<br>
SUM &#8211; ustundagi qiymatlar yig&#0145;indisi;<br>
AVG &#8211; ustundagi qiymatlarning o&#0145;rtachasi;<br>
COUNT &#8211; ustundagi NULL dan farqli bo&#0145;lgan qiymatlar miqdori.<br>
Quyidagi so&#0145;rov talabalar imtixonlarda olgan ballarining o&#0145;rtachasini aniqlaydi.<br>
SELECT AVG(mark) FROM mark_st<br>
<br>
SQL tili Oddiy so&#0145;rovlari. <br>
<br>
	Sozdayte zapros s imenem &#171;Sam?y prostoy zapros&#187;, kotor?y v?chislyaet znachenie v?rajeniya &#171;2+2&#187; i v?daet teku?ee vremya, ne ispolzuya pri etom tablis? ili drugie zapros? baz? dann?x.<br>
SELECT 2+2;<br>
<br>
SELECT ma&#0145;lumotlarni tanlash operatori<br>
<br>
Ma&#0145;lumotlarni tanlash SELECT operatori yordamida bajariladi. Bu SQL tilining  eng ko&#0145;p qo&#0145;llaniladigan operatori xisoblanadi. SELECT operatorini sintaksisi quyidagicha:<br>
SELECT [ALL/DISTINCT] <atributlar ro&#0145;yxati>/*<br>
FROM <jadvallar ro&#0145;yxati ><br>
[WHERE <tanlash sharti >]<br>
[ORDER BY < atributlar ro&#0145;yxati >]<br>
[GROUP BY < atributlar ro&#0145;yxati >]<br>
[HAVING <shart>]<br>
[UNION< SELECT operatorli ifoda>]<br>
<br>
Kvadrat qavslrda operatorni yozishda qatnashishi shart bo&#0145;lmagan elementlar ko&#0145;rsatilgan. ALL kalit so&#0145;zi natijaga shartni qanoatlantiruvchi barcha satrlar , shuningdek takrorlanuvchi satrlar ham kirishini bildiradi. DISTINCT kalit so&#0145;zi natijaga takrorlanuvchi satrlar kiritilmasligini bildiradi. Keyin bolang&#0145;ich jadvaldagi atributlar ro&#0145;yxati ko&#0145;rsatiladi. Bu atributlar natijaviy jadvalga kiritiladi. * simvoli natijaviy jadvalga boshlang&#0145;ich jadvalning barcha atributlari kiritilishini bildiradi.<br>
Operatorda qatnashishi shart bo&#0145;lgan so&#0145;zlardan FROM so&#0145;zi xisoblanadi. Bu so&#0145;zdan keyin tanlov bajariladigan jadvallar nomi ko&#0145;rsatiladi.<br>
Tanlash ifodasida WHERE  kalit so&#0145;zidan keyin jadval satrlarini tanlab olish sharti ko&#0145;rsatiladi. Bunda natijaviy jadvalga WHERE  ifodasidagi shart rost qiymat qabul qiladigan satrlar kiritiladi.<br>
ORDER BY kalit so&#0145;zi natijaviy jadval satrlarini ko&#0145;rsatilgan ustunlar ro&#0145;yxati bo&#0145;yicha tartiblash amalini bildiradi.<br>
GROUP BY kalit so&#0145;zidan keyin gruppalanadigan atributlar ro&#0145;yxati ko&#0145;rsatiladi. <br>
HAVING ifodasida har bir gruppaga qo&#0145;yiladigan shartlar ko&#0145;rsatiladi. (GROUP BY va HAVING kalit so&#0145;zlari keyinroq tushuntiriladi)<br>
FROM, WHERE va ORDER BY kalit so&#0145;zlari SQL tilining qolgan ma&#0145;lumotlarni manipulyatsiyalash operatorlarida ham shu tarzda ishlatiladi.<br>
So&#0145;rovlar yaratishni aniq misol uchun ko&#0145;rib o&#0145;tamiz (1-rasm)<br>
Barcha studentlar ro&#0145;yxatini tanlash va tasvirlash.<br>
SELECT *<br>
FROM student<br>
yoki <br>
SELECT id_st, surname<br>
FROM student<br>
Agar ushbu so&#0145;rovga ORDER BY surname ifodasi qo&#0145;shilsa, uxolda ro&#0145;yxat familiya bo&#0145;yicha tartiblanadi. Jimlikka ko&#0145;ra tartiblash o&#0145;sish bo&#0145;yicha  bajariladi. Agar kamayish bo&#0145;yicha tartiblash kerak bo&#0145;lsa, u xolda oxirgi ifodadagi atribut nomidan keyin DESC so&#0145;zi qo&#0145;shiladi..<br>
&#171;1&#187; kodli  student olgan baxolar ro&#0145;yxatini tanlab olish va tasvirlash<br>
SELECT id_st, mark<br>
FROM mark_st<br>
Where id_st = 1<br>
<br>
<br>
Ekzamenlarda kamida bitta 2 yoki 3 baxo olgan studentlar kodini tanlab olish<br>
<br>
WHERE so&#0145;zidan keyin solishtirish amallarini (<, >, =, <> va x.k.) va mantiqiy operatorlar qatnashgan ifodalarni joylashtirish mumkin.<br>
SELECT id_st, mark<br>
FROM mark_st<br>
WHERE ( MARK >= 2 ) AND ( MARK <= 3 )<br>
SQL  tilida shart ifodalarini tuzish uchun solishtirish va mantiqiy operatorlardan tashqari yana bir qator maxsus operatorlar qo&#0145;llaniladi. Bu operatorlar dasturlash tillarida mavjud emas. Bu operatolar:<br>
IN &#8211; biror qiymatlar to&#0145;plamiga tegishliligini tekshirish;<br>
BETWEEN &#8211; biror qiymatlar diapozoniga tegishliligini tekshirish;<br>
LIKE &#8211; namuna bilan mosligini tekshirish;<br>
IS NULL &#8211; qiymat mavjudmasligini tekshirish.<br>
IN operatori biror qiymatlar to&#0145;plamiga tegishlilikni tekshirish uchun ishlatiladi.<br>
Quyidagi so&#0145;rov oxigi keltirilgan misoldagi so&#0145;rov natijalarini beradi (ekzamenlarda kamida bitta 2 yoki 3 baho olgan studentlarni identifikatorini tanlab oladi)<br>
SELECT id_st, mark<br>
FROM mark_st<br>
WHERE mark IN (2,3)<br>
Xuddi natijani BETWEEN  operatoridan foydalanib olish mumkin:<br>
SELECT id_st, mark<br>
FROM mark_st<br>
WHERE mark BETWEEN 2 AND 3<br>
<br>
Familiyalari A xarfi bilan boshlanuvchi studentlar ro&#0145;yxatini tanlab olish<br>
<br>
Bunday xolatda LIKE  operatoridan foydalanish qulay xisoblanadi. LIKE operatori faqat simvolli maydonlar uchun qo&#0145;llaniladi va maydon qiymati operatorda ko&#0145;rsatilgan namunaga mosligini tekshirish imkonini yaratadi. Namuna quyidagi maxsus simvollardan tashkil topadi:<br>
_ (tagiga chizish belgisi) &#8211; bitta ixtiyoriy simvolni bildiradi;<br>
% (foiz belgisi) &#8211; ixtiyoriy miqdordagi simvollar ketma &#8211; ketligini bildiradi.<br>
SELECT id_st, surname<br>
FROM student<br>
WHERE surname LIKE 'A%'<br>
Ko&#0145;pincha ustunlardagi minimal, maksimal yoki o&#0145;rtacha qiymatlarni xisoblashga to&#0145;g&#0145;ri keladi. Masalan, keltiligan jadvallarda o&#0145;rtacha baxoni xisoblash mumkin. Bunday xisoblashni bajarish uchun  SQL  tilida maxsus agregat funksiyalari mavjud:<br>
MIN() &#8211; ustundagi minimal qiymat;<br>
MAX() &#8211; ustundagi maksimalqiymat;<br>
SUM() &#8211; ustundagi qiymatlar summasi;<br>
AVG() &#8211; ustundagi qiymatlarni o&#0145;rtachasi;<br>
COUNT() &#8211; ustundagi NULL dan farqli qiymatlar miqdori.<br>
Quyidagi so&#0145;rov studentlar olgan baxolarning o&#0145;rtachasini xisoblaydi.<br>
SELECT AVG(mark)<br>
FROM mark_st<br>
<br>
Albatta, agregat funksiyalarini WHERE so&#0145;zi bilan birgalikda qo&#0145;llash mumkin. Quyidagi so&#0145;rov 100 kodli studentning ekzamenlarda olgan baxolarining o&#0145;rtachasini xisoblaydi:<br>
SELECT AVG(mark)<br>
FROM mark_st<br>
WHERE id_st = 100<br>
Navbatdagi so&#0145;rov 10 kodli studentning o&#0145;rtacha baxosini xisoblaydi:<br>
SELECT AVG(mark)<br>
FROM mark_st<br>
WHERE id_ex = 10<br>
<br>
SQL tili ko&#0145;rib o&#0145;tilgan mexanizmiga qo&#0145;shimcha ravishda agregat funksiyalarni to&#0145;la jadval uchun emas, balki gruppalangan qiymatlar uchun qo&#0145;llash imkonini beruvchi vosita mavjud. Buning uchun SQL da maxsus GROUP BY konstruksiyasi mavjud bo&#0145;lib unda ko&#0145;rsatilgan ustun qiymatlari bo&#0145;yicha gruppalash amalga oshiriladi. Masalan, har bir studentni ekzamenlarda olgan baxolarining o&#0145;rtachasini aniqlash mumkin. Buning uchun quyidagi so&#0145;rov beriladi:<br>
SELECT id_st, AVG(mark)<br>
FROM mark_st<br>
GROUP BY id_st<br>
<br>
Bu imkoniyat ham odatdagidek WHERE so&#0145;zi bilan birgalikda qo&#0145;llanilishi mumkin. Bu so&#0145;rovni bajarishda MBBT avval jadvaldan WHERE ifodasidagi shartni qanoatlantiruvchi satrlarni tanlab oladi, keyin tanlangan satrlarni gruppalashva agregatlash amalini bajaradi.<br>
Quyidagi so&#0145;rov har bir studentning 100 kodli ekzamendan olgan baxolarining o&#0145;rtachasini aniqlaydi.<br>
SELECT id_st, AVG(mark)<br>
FROM mark_st<br>
WHERE id_ex = 100<br>
GROUP BY id_st<br>
<br>
Ko&#0145;rib turganimizdek gruppalash bittadan ko&#0145;p maydon bo&#0145;yicha bajarilishi mumkin. GROUP BY seksiyasiga ega bo&#0145;lgan so&#0145;rovlar uchun quyidagi muxim cheklanish mavjud: bunday so&#0145;rovlar natijasi tarkibiga gruppalash bajarilgan ustunlar va agregatlash natijasiga ega bo&#0145;lgan ustunlar kiradi.<br>
Biror xulosaga kelishdan oldin SQL tilining barcha imkoniyatlarini ko&#0145;rib chiqish kerak. Masalan, ixtiyoriy tekstni so&#0145;rov tarkibiga kiritish mumkin. Bunga misol keltiramiz:<br>
SELECT 'O&#0145;rtacha ball =&#8217;, AVG(mark)<br>
FROM mark_st<br>
WHERE id_ex = 10<br>
Ushbu so&#0145;rov natijasida foydalanuvchi faqat oddiy sonlarni emas, balki tekstni ham ko&#0145;radi.<br>
<br>
Bir necha jadvallardan ma&#0145;lumotlarni tanlash uchun  SQL ni qo&#0145;llash<br>
<br>
Sh paytgacha faqat bitta jadvaldan ma&#0145;lumotlarni tanlash miollari keltirildi. Relyatsion amallarga mos bo&#0145;lgan bir nechcha jadvallardan ma&#0145;lumotlar tanlab olishni  ham bajarish mumkin.  Bir nechta jadvallardan ma&#0145;lumotlarni tanlab olishga to&#0145;liq  misollar keltirish imkoni yo&#0145;q. Bunga doir ba&#8217;zi misollarni ko&#0145;rib o&#0145;tamiz.<br>
Qoidaga ko&#0145;ra, ma&#0145;lumotlar tanlab olinadigan jadvallar u yoki bu shaklda bir biri bilan bog&#0145;langan. Masalan, birga ko&#0145;p va x.k.<br>
1 rasmdagi ER-diagrammaga qarang. Bu miolda bog&#0145;langan jadvallar mavjud. student, mark_st va exam_st jadvallarini ko&#0145;rib chiqamiz.<br>
mark_st jadvali id_ex maydoni bo&#0145;yicha exam_st jadvali bilan bog&#0145;langan.<br>
mark_st jadvali id_st maydoni bo&#0145;yicha student jadvali bilan bog&#0145;langan.<br>
Masalan, studentlarni ro&#0145;yxatini ular ekzamenlardan olgan baxolari bilan birgalikda tanlash zarur bo&#0145;lsin. Buning uchun  quyidagi so&#0145;rov beriladi:<br>
SELECT student.surname, mark_st.id_ex, mark_st.mark<br>
FROM student, mark_st<br>
WHERE student.id_st = mark_st.id_st<br>
Keltirilgan ko&#0145;p jadvalli so&#0145;rov bir jadvalli so&#0145;rovdan quyidagilar bilan farq qiladi.<br>
1. FROM seksiyasida ikkita jadvl ko&#0145;rsatilgan.<br>
2. jadvallr soni bitta ko&#0145;p, shuning uchun ko&#0145;rsatilgan maydonlar nomining bir qiymatliligi yo&#0145;qoladi. Masalan, ko&#0145;p xollarda maydonni FROM da ko&#0145;rsatilgan jadvallar ro&#0145;yxatidagi qaysi jadvaldan olish noma&#8217;lum bo&#0145;lib qoladi. Maydon nomlarining ko&#0145;p qiymatliligini bataraf etish uchun maydon nomida perefiks - jadval nomi qo&#0145;shimcha qilinadi. Jadval nomi maydon nomidan nuqta bilan ajratiladi.<br>
 3. WHERE ifodasida jadvallarni birlashtirish sharti ko&#0145;rsatiladi.<br>
Ko&#0145;rinib turganidek jadval nomidan iborat prefiksdan foydalanish so&#0145;rovni murakkablashtiradi. Bunday murakkablikni bartaraf etish uchun psevdonim ishlatiladi. Yuqoridagi so&#0145;rovni quyidagicha yozish mumkin:<br>
SELECT E.surname, M.id_ex, M.mark<br>
FROM student E, mark_st M<br>
WHERE E.id_st = M. id_st<br>
<br>
INSERT ma&#0145;lumotlarni kiritish operatori:<br>
<br>
INSERT INTO jadval_nomi [(<ustunlar ro&#0145;yxati >) ] VALUES (<qiymatlar ro&#0145;yxati >)<br>
Bunday sintaksis jadvalga faqat bitta star kiritish imkonini beradi. Agar satrdagi barcha ustunlarga qiymat kiritilayotgan bo&#0145;lsa, so&#0145;rovda barcha ustunlar nomini ko&#0145;rsatish zarur emas.<br>
Masalan, BOOKS jadvaliga yangi kitob ma&#0145;lumotlari kiritiladi<br>
INSERT INTO BOOKS ( ISBN, TITL, AUTOR, COAUTOR, YEARIZD, PAGES)<br>
VALUES ("5-88782-290-2","Apparatn?e sredstva IBM PC.Ensiklopediya", <br>
&#34;Guk M. ", "",2000, 816)<br>
Bu kitob avtori faqat bitta va soavtor (hammuallif) mavjud emas, biroq ustunlar ro&#0145;yxatida COAUTOR  ustuni ham ko&#0145;rsatilgan. Shuning uchun VALUES bo&#0145;limida bu ustunga mos qiymatni ko&#0145;rsatish zarur. Misolda bu maydon uchun bo&#0145;sh satr ("") ko&#0145;rsatilgan. Bu soavtor yo&#0145;qligini bildiradi. Shuningdek bu yerda aniqlangmagan NULL qiymatini ko&#0145;rsatish ham mukin edi.<br>
Satrdagi barcha ustunlarga qiymat kiritishda ustunlar ro&#0145;yxatini ko&#0145;rsatish zarur emas. Bunda faqat qiymatlar ro&#0145;yxatini ko&#0145;rsatish yetarli bo&#0145;ladi. Bunday xolda operator ko&#0145;rinish quyidagicha shaklda bo&#0145;ladi:<br>
INSERT INTO BOOKS VALUES ("5-88782-290-2",<br>
"Apparatn?e sredstva IBM PC. Ensiklopediya"."Guk M.","".2000.816)<br>
Misolda keltirilgan ikkiala operator ham bir xil amalni bajaradi.<br>
Shuningdek to&#0145;liq miqdorda bo&#0145;lmagan qiymatlarni ko&#0145;rsatish mumkin. Ya&#8217;ni iymatlar qatorida soavtorni ko&#0145;rsatmaslik mumkin, chunki jeoriy kitobda soavtor yo&#0145;q. Biroq bunda  qiymat kiritiladigan ustun nomlarini quyidagicha shaklda ko&#0145;rsatish kerak bo&#0145;ladi:<br>
<br>
INSERT INTO BOOKS ( ISBN, TITL, AUTOR, YEARIZD,PAGES)<br>
VALUES ("5-88782-290-2"."Apparatn?e sredstva IBM PC.<br>
Ensiklopediya". Guk M.".2000,816)<br>
<br>
Bu xolda COAUTOR ustuniga NULL qiymati yoziladi.<br>
Agar jadvalni yaratishda ustun yoki atributga majburiy qiymat (NOT NULL) belgisi qo&#0145;yilgan bo&#0145;lsa, u xolda INSERT operatorida joriy ustunning har bir satriga kiritiladigan qiymatg ko&#0145;rsatilishi kerak. Shuning uchun, agar jadvalning hamma ustuni majburiy qiymat li bo&#0145;lsa, u xolda har bir yangi kiitladigan satrda barcha ustun uchun qiymat mavjud bo&#0145;lishi kerak va bunda ustunlar ro&#0145;yxatini ko&#0145;rsatish shar emas. Aks xolda jadvalda kamida bitta maburiy qiymatli bo&#0145;lmagan ustun bo&#0145;lsa, u xolda albatta ustunlar ro&#0145;yxatini ko&#0145;rsatish shart bo&#0145;ladi.<br>
Qiymatlar ro&#0145;yxatida maxsus funksiyalar va ifodalar ko&#0145;rsatilish ham mumkin. Bunda ushbu funksiyalarning qiymatlari ma&#0145;lumotlarni kiritish momentida xisoblangan bo&#0145;lishi zarur.<br>
Ma&#0145;lumotlarni kiritish operatori birdaniga bir necha satrlarni kiritish imkoniga ham ega. Bunda qiymatlar satri boshqa bir jadvaldan tanlab olinadi. Masalan studentlar xaqidagi jadval mavjud bo&#0145;lsin. Unda studentlarning familiyasi, adresi, uy telefoni va tug&#0145;ilgan sanasi ko&#0145;rsatilgan bo&#0145;lsin. U xolda bitta operator yordamida ularni bibliotekaning kitobxonlariga aylantirish mumkin:<br>
<br>
INSERT INTO READER (FIO_studenta, Adres, Telefon, Data_rojd)<br>
SELECT (FIO_studenta, Adres, Telefon, Den_rojd)<br>
FROM STUDENT<br>
<br>
DELETE o&#0145;chirish operatori:<br>
<br>
Ma&#0145;lumotlarni o&#0145;chirish operatori jadvaldan shartni qanoatlantiruvchi bir yoki bir neta satrlarni o&#0145;chirishi mumkin.<br>
<br>
DELETE FROM jadval _nomi [WHERE tanlash_sharti]<br>
<br>
Agar satrlarni tanlash sharti ko&#0145;rsatilmasa, u xolda jadvaldagi barcha satrlar o&#0145;chiriladi. Natijada ma&#0145;lumotlarga ega bo&#0145;lmagan bo&#0145;sh bo&#0145;lgan jadval xosil bo&#0145;ladi.<br>
Agar jadvaldan oldingi sessiya natijalarini o&#0145;chirish kerak bo&#0145;lsa, u xolda R1 jadvalidagi barcha satrlar o&#0145;chiriladi:<br>
<br>
DELETE FROM R1<br>
<br>
WHERE  qismidagi shart ifodasi xuddi  SELECT operatoridagi filtrlash shartiga o&#0145;xshash bo&#0145;ladi. Bu shart jadvaldan qaysi satrlar o&#0145;chirilishi kerakligini aniqlaydi.<br>
Masalan, student Mironova A.V. o&#0145;chirilmaslii kerak bo&#0145;lsa, quyidagi so&#0145;rov beriladi:<br>
<br>
DELETE FROM R2 WHERE FIO = &#34;Mironov A.V.&#34;<br>
<br>
WHERE qismida biror so&#0145;rov ko&#0145;rsatilishi mumkin. Masalan, agar jadvaldan o&#0145;zlashtirmagan studentlarni o&#0145;chirish kerak bo&#0145;lsin. Oliy ta&#8217;lim qonuniga ko&#0145;ra oxirgi sessiyada ikkita va undan ortiq fandan ikki baxo olgan student o&#0145;zlashtirmagan xisoblanadi. U xolda tanlab olish sharti ikkita va undan ko&#0145;p ikki baxo olgan studentlarni va ikkita undan ko&#0145;p ekzamenlarni topshirmagan studentlarni aniqlashi kerak. Bunday studentlarni aniqlash uchun R1 jadvalidan 2 baxoli va baxo ko&#0145;rsatilmagan satrlar tanlab olinishi, keyin olingan natija FIO ustuni bo&#0145;yicha gruppalanishi kerak. Keyin  har bir gruppadagi satrlar soni aniqlanadi (bu har bir studentning olgan ikki baxolari bilan topshirmagan ekzamenlar sonini bildiradi) va ikkitadan ko&#0145;p satrga ega ustunlar tanlab olinadi. Endi ushbu murakkab bo&#0145;lgan konstruksiyani SQL tilida yozamiz va sodda ko&#0145;rinishga ega bo&#0145;lishini ko&#0145;ramiz.<br>
<br>
DELETE FROM R2 WHERE R2.FIO IN (SELECT R1.FIO FROM R1<br>
WHERE Otsenka = 2 OR Otsenka IS NULL GROOP BY R1.FIO HAVING COUNT(*)<br>
>= 2<br>
DELETE operatsiyasini bajarishda unda qatnashgan qism so&#0145;rovda satrlar o&#0145;chiriladigan jadval ko&#0145;rsatilmasligi kerak. <br>
Ma&#0145;lumotlarni manipulyatsiyalash operatsiyalarining barchasi ma&#0145;lumotlar bazasining butunligi tushunchasi bilan bog&#0145;langan. Manipulyatsiyalash amallari sintaktik jixatdan to&#0145;g&#0145;ri bo&#0145;lsada butunlik talablari tufayli bajarilmasligi mmkin.<br>
<br>
UPDATE ma&#0145;lumotlarni yangilash operatsiyasi<br>
<br>
 o&#0145;zgarish yuz berganda va mos xolda bu o&#0145;zgarishni ma&#0145;lumotlar bazasida akslantirish uchun ishlatiladi.<br>
<br>
UPDATE jadval _nomi SET ustun_nomi = yangi_qiymat [WHERE tanlash_sharti]<br>
<br>
Bu yerda ham WHERE qismi DELETE operatoridagi kabi ko&#0145;rsatilishi shart emas. U  DELETE operatoridagi kabi bir xil vazifani bajaradi va o&#0145;zgartirish amali bajariladigan satlarni tanlash imkonini beradi. Agar tanlash sharti (WHERE qismi) ko&#0145;rsatilmagan bo&#0145;lsa, u xolda o&#0145;zgartirish amali jadvlning barcha satrlari uchun bajariladi.<br>
Masalan,  student Stepanova K. Ye. ma&#0145;lumotlar bazasi fanidan &#34;2&#34; baho oldi, keyin uni &#34;3&#34; bahoga qayta topshirgan bo&#0145;lsin.  Bu xolatga mos xolda R1 jadvalini o&#0145;zgartirish amali quyidagi operator bilan amalga oshiriladi:<br>
<br>
UPDATE R1<br>
SET R1.Otsenka = 3<br>
WHERE R1.FIO = "Stepanova K.Ye." AND R1.Dissiplina = "Baz? dann?x"<br>
<br>
Qanday xolatlarda bir nechta satrlarni o&#0145;zgartirish zarurati paydo bo&#0145;ladi? Bu kam uchaydigan masala emas. Masalan, agar guruxlar jadvalidagi guruxlarni kursini bittaga oshirish zarr bo&#0145;lsa quyidagi o&#0145;zgartirish amali bajarishi mumkin. Guruxlar jadvali quyidagicha sxemaga ega bo&#0145;lsin:<br>
<br>
R4 = < Gurux, Kurs><br>
<br>
UPDATE R4<br>
SET R4.Kypc = R4.Kypc + 1<br>
<br>
Ma&#0145;lumotlarni turi. Ma&#0145;lumotlar bazasini yaratish<br>
<br>
MYSQL tilida jadvaldagi maydonlarni quyidagi tiplari mavjud [2]:<br>
Ma&#0145;lumotlarni aniqlash<br>
<br>
SQL ning DDL (Data Definition Language) ma&#0145;lumotlarni aniqlash tili ma&#0145;lumotlar bazasining sxema, domenlar, jadvallar, tasvirlar va indekslar kabi ob&#8217;ektlarini yaratish va o&#0145;chirish uchun ishlatiladi. <br>
Quyida SQL da ma&#0145;lumotlarni aniqlash tilining asosiy operatorlari nomi keltirilgan.<br>
<br>
CREATE SCHEMA 									DROP SCHEMA<br>
CREATE DOMAIN 			ALTER DOMAIN 				DROP DOMAIN<br>
CREATE TABLE 			ALTER TABLE 				DROP TABLE<br>
CREATE VIEW									DROP VIEW<br>
Bu operatorlar konseptual sxemaning tarkibiga kiruvchi strukturalarni yaratish, taxrirlash va o&#0145;chirish uchun ishlatiladi. Ba&#8217;zi MBBT larda quyidagi 2 ta operator xam mavjud:<br>
<br>
CREATE INDEX 			DROP INDEX<br>
<br>
Jadvallarni yaratish<br>
<br>
    Jadvallar CREATE TABLE komandasi bilan yaratiladi. Bu komanda qatorlarsiz bo&#0145;sh jadval yaratadi. CREATE TABLE komandasi jadval nomini va jadvalning  o&#0145;zini ko&#0145;rsatilgan tartibdagi ustunlar ketma &#8211; ketligi ko&#0145;rinishida aniqlaydi. Unda har bir ustundagi ma&#0145;lumotlarning tiplari va ustunlar o&#0145;lchovi ko&#0145;rsatiladi. Har bir jadval juda bo&#0145;lmaganda bitta ustunga ega bo&#0145;lishi kerak. <br>
CREATE TABLE    komandasi sintaksisi:<br>
<br>
    CREATE TABLE <table-name ><br>
         ( <column name> <data type>[(<size>)],<br>
           <column name> <data type>[(<size>)], ... );<br>
<br>
Argument qiymati kattaligi ma&#0145;lumot turiga bog&#0145;liqdir. Agar siz maxsus ko&#0145;rsatmasangiz, tizim avtomatik qiymatni o&#0145;rnatadi.<br>
    Misol uchun sotuvchilar jadvalini yaratishni ko&#0145;rib chiqamiz:<br>
CREATE TABLE Salepeople<br>
      ( SNum    integer,<br>
        SName   char (10),<br>
        City       char (10),<br>
        Comm   decimal );<br>
  <br>
Jadvallarni o&#0145;chirish<br>
<br>
    Jadvalni o&#0145;chirish imkoniga ega bo&#0145;lish uchun, jadval egasi (Ya&#8217;ni yaratuvchisi) bo&#0145;lishingiz kerak. Faqat bo&#0145;sh jadvalni o&#0145;chirish mumkin. Qatorlarga ega bo&#0145;lgan, to&#0145;ldirilgan jadvalni o&#0145;chirish mumkin emas, Ya&#8217;ni jadval o&#0145;chirishdan oldin tozalangan bo&#0145;lishi kerak. Jadvalni o&#0145;chirish komandasi quyidagi ko&#0145;rinishga ega:<br>
  DROP TABLE < table name >;<br>
  Masalan: DROP TABLE Salepeople;<br>
<br>
Jadvalni o&#0145;zgartirish<br>
<br>
    Jadvalni o&#0145;zgartirish uchun ALTER TABLE komandasidan foydalaniladi. Bu komanda jadvalga Yangi ustunlar qo&#0145;shish, ustunlarni o&#0145;chirish, ustunlar kattaligini o&#0145;zgartirish,hamda cheklanishlarni qo&#0145;shish va olib tashlash imkoniyatlariga ega. Bu komanda ANSI standarti qismi emas, shuning uchun har xil tizimlarda har xil imkoniyatlarga ega.<br>
Jadvalga ustun qo&#0145;shish uchun komandaning tipik sintaksisi:<br>
 ALTER TABLE <table name> ADD <column name> <br>
                             <data type> <size>;<br>
  Masalan:<br>
  ALTER TABLE Salepeople ADD Phone CHAR(7);<br>
<br>
Jadvallar uchun cheklanishlar<br>
Cheklanishlarni aniqlash.<br>
   Ko&#0145;p xollarda ustunga kiritilgan qiymatlar bir biridan farq qilishi kerak. Agar ustun uchun UNIQUE cheklanishi o&#0145;rnatilsa, bu ustungsha mavjud qiymatni kiritishga urinish rad etilapdi. Bu cheklanish bo&#0145;sh bo&#0145;lmaydigan (NOT NULL) debe&#8217;lon qilingan maydonlarga qo&#0145;llanishi mumkin. <br>
    Masalan:<br>
  CREATE TABLE Salepeople<br>
          ( SNum     integer NOT NULL UNIQUE,<br>
            SName   char (10),<br>
            City        char (10),<br>
            Comm    decimal);<br>
Unikalligi talab qilinadigan maydonlar(birlamchi kalitlardan tashqari) kandidat kalitlar yoki unikal kalitlar deyiladi.<br>
Jadval cheklanishi UNIQUE maydonlar guruxiga o&#0145;rnatilishi mumkin. Bu bir necha maydonlar qiymatlari kombinatsiyasi unikalligini ta&#8217;minlaydi. Bizning ma&#0145;lumotlart bazamizda har bir buyurtmachi bitta sotuvchiga biriktirilgan. Ya&#8217;ni Buyurtmachilar jadvalida buyurtmachi nomeri (cnum) va sotuvchi nomeri (snum) kombinatsiyasi unikal bo&#0145;lishi kerak. Bu cheklanishni UNIQUE  (cnum, snum) yordamida, Customers jadvalini yaratishda kiritish mumkin. Bu ustunlar uchun NOT NULL  cheklanishini kiritish zarurdir.<br>
Birlamchi kalitlar cheklanishlari.<br>
  SQL birlamchi kalitlarni to&#0145;g&#0145;ridan to&#0145;g&#0145;ri birlamchi kalit  (PRIMARY KEY) cheklanishi orqali ta&#8217;riflaydi. PRIMARY KEY jadvalni yoki ustunlarni cheklashi mumkin. Bu cheklanish UNIQUE cheklanishi kabi ishlaydi,  jadval uchun faqat bitta birlamchi kalit (ixtiyoriy sondagi ustunlar uchun ) aniqlanishi mumkin bo&#0145;lgan xoldan tashqari. Birlamchi kalitlar  NULL qiymatga ega bo&#0145;lishi mumkin emas.<br>
    Misol:<br>
  CREATE TABLE Salepeople<br>
          ( SNum     integer NOT NULL PRIMARY KEY,<br>
            SName   char (10),<br>
            City        char (10),<br>
            Comm    decimal);<br>
     Maydon qiymatlarini tekshirish (CHECK cheklanishi).<br>
    CHECK cheklanishi jadvalga kiritilayotgan ma&#0145;lumot qabul qilinishidan oldin mos kelishi lozim bo&#0145;lgan shart kiritishga imkon beradi. CHECK cheklanishi CHECK kalit so&#0145;zi ko&#0145;rsatilgan maydondan foydalanuvchi predikat ifodalaridan iboratdir.<br>
    Misol: Salepeople jadvali Comm ustuniga kiritilayotgan qiymat 1 dan kichik bo&#0145;lish sharti.<br>
CREATE TABLE Salepeople<br>
     ( SNum     integer NOT NULL PRIMARY KEY,<br>
       SName    char(10) NOT NULL UNIQUE,<br>
       City        char(10),<br>
       Comm    decimal CHECK ( Comm < 1 ));<br>
<br>
Ko&#0145;zda tutilgan qiymatlarni (poumolchaniyu) o&#0145;rnatish<br>
<br>
Biror bir maydon uchun qiymat ko&#0145;rsatmagan xolda jadvalga satr qo&#0145;shsangiz, SQL bunday maydonga kiritish uchun ko&#0145;zda tutilgan qiymatga ega bo&#0145;lishi kerak, aks xolda komanda rad etiladi. Eng umumiy ko&#0145;zda tutilgan qiymat NULL qiymatdir. CREATE TABLE komandasida ko&#0145;zda tutilgan qiymat DEFAULT operatori orqali, ustun cheklanishi sifatida ko&#0145;rsatiladi. Masalan:<br>
CREATE TABLE Salepeople<br>
     ( SNum     integer NOT NULL PRIMARY KEY,<br>
       SName    char(10) NOT NULL UNIQUE,<br>
       City        char(10) DEFAULT 'New York',<br>
       Comm    decimal CHECK ( Comm < 1 ));<br>
<br>
Ma&#0145;lumotlar yaxlitligini ta&#8217;minlash<br>
<br>
    Jadval bir maydonidagi hamma qiymatlar boshqa jadval maydonida aks etsa, birinchi maydon ikkinchisiga ilova qiladi deyiladi. Bu ikki maydon orasidagi bog&#0145;liqlikni ko&#0145;rsatadi. Masalan, buyurtmachilar jadvalida har bir buyurtmachi, sotuvchilar jadvalida o&#0145;ziga biriktirilgan sotuvchiga ilova qiluvchi SNum maydoniga ega. Bir maydon ikkinchisiga ilova qilsa  tashqi kalit, u ilova qilayotgan maydon ajdod kalit deyiladi. Buyurtmachilar jadvalidagi SNum  maydoni tashqi kalit, sotuvchilar jadvalidagi SNum - ajdod kalitdir. <br>
Tashqi kalit bitta maydondan iborat bo&#0145;lishi shart emas. Birlamchi kalit kabi, tashqi kalit bitta modul sifatida qayta ishlanuvchi bir necha maydonlarga ega bo&#0145;lishi musmkin.  Maydon tashqi kalit bo&#0145;lsa ilova qitlayotgan jadval bilan ma&#8217;lum usulda bog&#0145;liqdir. Tashqi kalit har bir qiymati (satri), ajdod kalitning bitta va faqat bitta qiymatiga( satriga) ilova qilishi kerak. Bu xolda tizim ilovali yaxlit xolatda deyiladi<br>
Shu bilan birga ajdod kalit qiymati tashqi kalit bir necha qiymatlariga ilova qilishi mumkin. <br>
Cheklanish FOREIGN KEY.<br>
    SQL ilovali yaxlitlikni FOREIGN KEY yordamida ta&#8217;minlaydi. Tashqi kalit vazifasi ajdod kalitda ko&#0145;rsatilmagan qiymatlarni tashqi kalit maydonlariga kiritmaslikdir. FOREIGN KEY cheklanishi sintaksisi:<br>
   FOREIGN KEY <column list> REFERENCES<br>
                               <pktable> [<column list>]<br>
    Birinchi ro&#0145;yxat komanda tomonidan o&#0145;zgartiriluvchi ustunlar ro&#0145;yxatidir. Pktable - bu ajdod kalitli jadval. Ikkinchi ustunlar ro&#0145;yxati bu ajdod kalitni tashkil qiluvchi ustunlardir.  <br>
Misol uchun Sotuvchilar jadvaliga ilova qiluvchi tashqi kalit sifatida e&#8217;lon qilingan SNum maydoniga ega bo&#0145;lgan Buyurtmachilar jadvalini yaratamiz:<br>
  CREATE TABLE Customers<br>
     ( CNum   integer NOT NULL PRIMARY KEY,<br>
       CName char(10),<br>
       City      char(10),<br>
       SNum   integer,<br>
       FOREIGN KEY (SNum) REFERENCES Salepeople (SNum) ); <br>
                            </p>
                        

                                        <embed width="750" height="400" src="https://www.youtube.com/v/t6mf0PBz0J0&list=PLWOjfMOVLtgJhiYXqGdlEJaRBHmfo3XIB&index=34&t=0s">

                    </div>

                <div class="little-info">
                        <h4 class="text-center"><span class="font-weight-bold">4-mavzuga doir savollar: </span></h4>
                        <ol>
                                                        <li> SELECT tanlash operatorining sintaksisi </li>
                                                        <li> IN, BETWEEN, LIKE, IS NULL operatorlari. Ularni ta&#8217;riflang va misollar keltiring. </li>
                                                        <li> Agregat funksiyalari. </li>
                                                        <li> SELECT operatorida yordamida bir nechta jadvallardan ma&#0145;lumotlarni tanshlash </li>
                                                        <li> SQL tilining INSERT ma&#0145;lumotlarni operatorlari. </li>
                                                        <li> SQL tilida ma&#0145;lumotlarning tiplari. </li>
                                                        <li> SQL DDL ma&#0145;lumotlarni aniqlash tili </li>
                                                        <li> SQL tilida jadvallar yaratish operatori </li>
                                                    </ol>
                    </div>

                </div>
            </div>
        </div>
    </div>
</div>
</div>
</div>
<div class="footer-copyright text-center py-3">Copyright 2019| <a href="https://sarvarazim.uz" style="color: white; ">SarvarAzim</a> corporation
  </div>
</body>

<script src="js/bootstrap.min.js"></script>
<script src="js/popper.min.js"></script>
<script src="js/jquery.min.js"></script>
</html>